<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TOTP Generator</title>
</head>

<body>

    <h1>TOTP Generator</h1>

    <label for="startupTests">Startup Tests: </label><div id="testResults" style="display: inline-block">?</div><br><br>

    <form id="totpForm">

        <label for="timestamp">Timestamp: </label>
        <input type="datetime-local" id="timestamp" name="timestamp" step="1"><br><br>

        <label for="sharedSecret">Shared Secret: </label>
        <input type="text" id="sharedSecret" name="sharedSecret" required><br><br>

        <label for="validityTime">Validity Time (seconds, optional): </label>
        <input type="number" id="validityTime" name="validityTime" value="30"><br><br>

        <label for="totpLength">TOTP Length (optional): </label>
        <input type="number" id="totpLength" name="totpLength" value="12"><br><br>

        <label for="alphabet">Alphabet (optional): </label>
        <input type="text" id="alphabet" name="alphabet" value="0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"><br><br>

        <button type="submit">Generate TOTP</button>

    </form>

    <br>

    <h2>Results:</h2>
    <pre id="totpResult"></pre>

    <script>

    function isLittleEndian() {
        const buf = new ArrayBuffer(4);
        new DataView(buf).setUint32(0, 1, true);
        return new Uint32Array(buf)[0] === 1;
    }

    function reverseBytes(buffer) {
        for (let i = 0; i < buffer.length / 2; i++) {
            let temp = buffer[i];
            buffer[i] = buffer[buffer.length - 1 - i];
            buffer[buffer.length - 1 - i] = temp;
        }
    }

    async function calcTOTPSlot(slotBytes,
                                TOTPLength,
                                alphabet,
                                sharedSecret) {

        // JavaScript's Buffer methods default to big-endian!
        if (!isLittleEndian())
            reverseBytes(slotBytes);

        const hash = await crypto.subtle.sign(
            "HMAC",
            await crypto.subtle.importKey(
                "raw",
                new TextEncoder().encode(sharedSecret),
                {
                    name: "HMAC",
                    hash: "SHA-256"
                },
                false,
                ["sign", "verify"]
            ),
            slotBytes
        );

        const currentHash = new Uint8Array(hash);
        const offset      = currentHash[currentHash.length - 1] & 0x0F;

        let result = '';
        for (let i = 0; i < TOTPLength; i++)
            result += alphabet[(currentHash[(offset + i) % currentHash.length] >>> 0) % alphabet.length];

        return result;

    }

    async function generateTOTPs(SharedSecret,
                                 ValidityTime  = null,
                                 TOTPLength    = null,
                                 Alphabet      = null,
                                 Timestamp     = null) {

        if (!ValidityTime) ValidityTime  = 30;
        if (!TOTPLength)   TOTPLength    = 12;
        if (!Alphabet)     Alphabet      = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';
        if (!Timestamp)    Timestamp     = Date.now();

        SharedSecret = SharedSecret?.trim();
        Alphabet     = Alphabet?.    trim();

        if (!SharedSecret)                              throw new Error("The given shared secret must not be null or empty!");
        if (/\s/.test(SharedSecret))                    throw new Error("The given shared secret must not contain any whitespace characters!");
        if (SharedSecret.length < 16)                   throw new Error("The length of the given shared secret must be at least 16 characters!");
        if (TOTPLength < 4)                             throw new Error("The expected length of the TOTP must be between 4 and 255 characters!");
        if (!Alphabet)                                  throw new Error("The given alphabet must not be null or empty!");
        if (Alphabet.length < 4)                        throw new Error("The given alphabet must contain at least 4 characters!");
        if (new Set(Alphabet).size !== Alphabet.length) throw new Error("The given alphabet must not contain duplicate characters!");
        if (/\s/.test(Alphabet))                        throw new Error("The given alphabet must not contain any whitespace characters!");

        var  currentUnixTime     = 0;

        if (typeof Timestamp === 'string')
            currentUnixTime = Math.floor(new Date(Timestamp).getTime() / 1000) - new Date().getTimezoneOffset() * 60;
        else if (typeof Timestamp === 'number')
            currentUnixTime = Timestamp;
        else
            throw new Error('Invalid timestamp format');

        const currentSlot        = BigInt(Math.floor(currentUnixTime / ValidityTime));
        const remainingTime      = ValidityTime - (currentUnixTime % ValidityTime);

        // For interoperability we use 8 byte timestamps
        const previousSlotBytes  = new Uint8Array(8);
        const currentSlotBytes   = new Uint8Array(8);
        const nextSlotBytes      = new Uint8Array(8);

        new DataView(previousSlotBytes.buffer).setBigUint64(0, currentSlot - BigInt(1));
        new DataView(currentSlotBytes.buffer). setBigUint64(0, currentSlot);
        new DataView(nextSlotBytes.buffer).    setBigUint64(0, currentSlot + BigInt(1));

        const previous           = await calcTOTPSlot(previousSlotBytes, TOTPLength, Alphabet, SharedSecret);
        const current            = await calcTOTPSlot(currentSlotBytes,  TOTPLength, Alphabet, SharedSecret);
        const next               = await calcTOTPSlot(nextSlotBytes,     TOTPLength, Alphabet, SharedSecret);

        return {
            previous,
            current,
            next,
            remainingTime
        };

    }


    // Set current date and time of the timestamp picker!
    const now     = new Date();
    const year    = now.getFullYear();
    const month   = String(now.getMonth()+1).padStart(2, '0');
    const day     = String(now.getDate()).   padStart(2, '0');
    const hours   = String(now.getHours()).  padStart(2, '0');
    const minutes = String(now.getMinutes()).padStart(2, '0');
    const seconds = String(now.getSeconds()).padStart(2, '0');

    const formattedDateTime = `${year}-${month}-${day}T${hours}:${minutes}:${seconds}`;
    document.getElementById('timestamp').value = formattedDateTime;


    // Handle 'generateTOTPs'-button
    document.getElementById('totpForm').addEventListener('submit', async function(event)
    {

        event.preventDefault();

        const sharedSecret  = document.getElementById('sharedSecret').value;
        const validityTime  = document.getElementById('validityTime').value;
        const totpLength    = document.getElementById('totpLength').  value;
        const alphabet      = document.getElementById('alphabet').    value;
        const timestamp     = document.getElementById('timestamp').   value;

        try
        {

            const result = await generateTOTPs(
                               sharedSecret,
                               validityTime ? parseInt(validityTime) : undefined,
                               totpLength   ? parseInt(totpLength)   : undefined,
                               alphabet     ? alphabet               : undefined,
                               timestamp
                           );

            document.getElementById('totpResult').textContent = JSON.stringify(result, null, 2);

        } catch (error) {
            document.getElementById('totpResult').textContent = `Error: ${error.message}`;
        }

    });


    async function main() {
        try
        {

            const result = await generateTOTPs(
                               'secure!Charging!',
                               60,
                               undefined,
                               undefined,
                               1716423785
                           );

            if (result.previous      == 'nTdkiuG6yUyg' &&
                result.current       == 'XJZr0L1DGKn0' &&
                result.next          == 'ft0ONZ62MdMj' &&
                result.remainingTime == 55)
            {
                document.getElementById('testResults').innerHTML = '<div style="color: green">ok!</div>';
            }
            else
                document.getElementById('testResults').innerHTML = '<div style="color: red">failed!</div>';

        } catch (error) {
            document.getElementById('testResults').innerHTML = `Error: ${error.message}`;
        }
    }

    document.addEventListener('DOMContentLoaded', main);

    </script>

</body>
</html>
